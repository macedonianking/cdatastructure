import("//build/config/android/config.gni")
import("//build/config/android/ijar.gni")

assert(is_android)

# 添加的生成target.build_config的模板
template("write_build_config") {
  type = invoker.type

  action(target_name) {
    set_sources_assignment_filter([])
    build_config = invoker.build_config

    assert(type == "android_apk" 
           || type == "java_library" 
           || type == "android_resources" 
           || type == "deps_dex" 
           || type == "android_assets" 
           || type == "resource_rewriter" 
           || type == "java_binary" 
           || type == "group" 
           || type == "java_prebuilt")

    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                           ])
    if (!defined(deps)) {
      deps = []
    }

    script = "//build/android/gyp/write_build_config.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = []

    _deps_configs = []
    if (defined(invoker.possible_config_deps)) {
      set_sources_assignment_filter([])
      foreach(_possible_dep, invoker.possible_config_deps) {
        _target_label = get_label_info(_possible_dep, "label_no_toolchain")
        deps += [ "${_target_label}__build_config" ]
        _dep_gen_dir = get_label_info(_possible_dep, "target_gen_dir")
        _dep_name = get_label_info(_possible_dep, "name")
        _deps_configs += [ "$_dep_gen_dir/$_dep_name.build_config" ]
      }
      set_sources_assignment_filter([])
    }
    _rebased_deps_configs = rebase_path(_deps_configs, root_build_dir)

    outputs = [
      build_config,
    ]

    args = [
      "--type",
      type,
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--deps-configs=$_rebased_deps_configs",
      "--build-config",
      rebase_path(build_config, root_build_dir),
    ]

    is_java = type == "java_library" || type == "java_binary" ||
              type == "java_prebuilt"
    is_apk = type == "android_apk"
    is_android_assets = type == "android_assets"
    is_android_resources = type == "android_resources"
    is_deps_dex = type == "deps_dex"
    is_group = type == "group"

    supports_android = is_apk || is_android_assets || is_android_resources ||
                       is_deps_dex || is_group ||
                       (is_java && defined(invoker.supports_android) &&
                        invoker.supports_android)
    requires_android =
        is_apk || is_android_assets || is_android_resources || is_deps_dex ||
        (is_java && defined(invoker.requires_android) &&
         invoker.requires_android)

    assert(!requires_android || supports_android,
           "requires_android requires" + " supports_android")

    # Mark these variables as used.
    assert(is_java || true)
    assert(is_apk || true)
    assert(is_android_resources || true)
    assert(is_deps_dex || true)
    assert(is_group || true)

    if (is_java || is_apk) {
      args += [
        "--jar-path",
        rebase_path(invoker.jar_path, root_build_dir),
      ]
    }

    if (is_apk || is_deps_dex || (is_java && supports_android)) {
      args += [
        "--dex-path",
        rebase_path(invoker.dex_path, root_build_dir),
      ]
    }
    if (supports_android) {
      args += [ "--supports-android" ]
    }
    if (requires_android) {
      args += [ "--requires-android" ]
    }
    if (defined(invoker.bypass_platform_checks) &&
        invoker.bypass_platform_checks) {
      args += [ "--bypass-platform-checks" ]
    }

    if (defined(invoker.apk_under_test)) {
      deps += [ "${invoker.apk_under_test}__build_config" ]
      apk_under_test_gen_dir =
          get_label_info(invoker.apk_under_test, "target_gen_dir")
      apk_under_test_name = get_label_info(invoker.apk_under_test, "name")
      apk_under_test_config =
          "$apk_under_test_gen_dir/$apk_under_test_name.build_config"
      args += [
        "--tested-apk-config",
        rebase_path(apk_under_test_config, root_build_dir),
      ]
    }

    if (is_android_assets) {
      if (defined(invoker.asset_sources)) {
        _rebased_asset_sources =
            rebase_path(invoker.asset_sources, root_build_dir)
        args += [ "--asset-sources=$_rebased_asset_sources" ]
      }
      if (defined(invoker.asset_renaming_sources)) {
        _rebased_asset_renaming_sources =
            rebase_path(invoker.asset_renaming_sources, root_build_dir)
        args += [ "--asset-renaming-sources=$_rebased_asset_renaming_sources" ]

        # These are zip paths, so no need to rebase.
        args += [ "--asset-renaming-destinations=${invoker.asset_renaming_destinations}" ]
      }
      if (defined(invoker.disable_compression) && invoker.disable_compression) {
        args += [ "--disable-asset-compression" ]
      }
    }

    if (is_android_resources || is_apk) {
      assert(defined(invoker.resources_zip))
      args += [
        "--resources-zip",
        rebase_path(invoker.resources_zip, root_build_dir),
      ]
      if (defined(invoker.android_manifest)) {
        inputs += [ invoker.android_manifest ]
        args += [
          "--android-manifest",
          rebase_path(invoker.android_manifest, root_build_dir),
        ]
      } else {
        assert(!is_apk, "apk build configs require an android_manifest")
      }
      if (defined(invoker.custom_package)) {
        args += [
          "--package-name",
          invoker.custom_package,
        ]
      }
      if (defined(invoker.r_text)) {
        args += [
          "--r-text",
          rebase_path(invoker.r_text, root_build_dir),
        ]
      }
    }

    if (is_android_resources && defined(invoker.resource_dirs)) {
      resource_dirs = rebase_path(invoker.resource_dirs, root_build_dir)
      args += [ "--resource-dirs=$resource_dirs" ]
    }

    if (is_apk) {
      if (defined(invoker.shared_libraries_runtime_deps_file)) {
        # Don't list shared_libraries_runtime_deps_file as an input in order to
        # avoid having to depend on the runtime_deps target. See comment in
        # rules.gni for why we do this.
        args += [
          "--shared-libraries-runtime-deps",
          rebase_path(invoker.shared_libraries_runtime_deps_file,
                      root_build_dir),
        ]
      }

      if (defined(invoker.secondary_abi_shared_libraries_runtime_deps_file)) {
        # Don't list secondary_abi_shared_libraries_runtime_deps_file as an
        # input in order to avoid having to depend on the runtime_deps target.
        # See comment in rules.gni for why we do this.
        args += [
          "--secondary-abi-shared-libraries-runtime-deps",
          rebase_path(invoker.secondary_abi_shared_libraries_runtime_deps_file,
                      root_build_dir),
        ]
      }

      if (defined(invoker.proguard_enabled) && invoker.proguard_enabled) {
        args += [
          "--proguard-enabled",
          "--proguard-info",
          rebase_path(invoker.proguard_info, root_build_dir),
        ]
      }

      if (defined(invoker.apk_path)) {
        _rebased_apk_path = rebase_path(invoker.apk_path, root_build_dir)
        _rebased_incremental_apk_path =
            rebase_path(invoker.incremental_apk_path, root_build_dir)
        _rebased_incremental_install_script_path =
            rebase_path(invoker.incremental_install_script_path, root_build_dir)
        args += [ "--apk-path=$_rebased_apk_path" ]
        args += [ "--incremental-apk-path=$_rebased_incremental_apk_path" ]
        args += [ "--incremental-install-script-path=$_rebased_incremental_install_script_path" ]
      }
    }

    if (defined(invoker.java_sources_file)) {
      args += [
        "--java-sources-file",
        rebase_path(invoker.java_sources_file, root_build_dir),
      ]
    }
    if (defined(invoker.srcjar)) {
      args += [
        "--srcjar",
        rebase_path(invoker.srcjar, root_build_dir),
      ]
    }
    if (defined(invoker.bundled_srcjars)) {
      _rebased_bundled_srcjars =
          rebase_path(invoker.bundled_srcjars, root_build_dir)
      args += [ "--bundled-srcjars=$_rebased_bundled_srcjars" ]
    }
    if (defined(invoker.input_jars_paths)) {
      _rebased_input_jars_paths =
          rebase_path(invoker.input_jars_paths, root_build_dir)
      args += [ "--extra-classpath-jars=$_rebased_input_jars_paths" ]
    }
    if (defined(invoker.proguard_configs)) {
      _rebased_proguard_configs =
          rebase_path(invoker.proguard_configs, root_build_dir)
      args += [ "--proguard-configs=$_rebased_proguard_configs" ]
    }
    if (current_toolchain != default_toolchain) {
      # This has to be a built-time error rather than a GN assert because many
      # packages have a mix of java and non-java targets. For example, the
      # following would fail even though nothing depends on :bar(//baz):
      #
      # shared_library("foo") {
      # }
      #
      # android_library("bar") {
      #   deps = [ ":foo(//baz)" ]
      #   assert(current_toolchain == default_toolchain)
      # }
      _msg = [
        "Tried to build an Android target in a non-default toolchain.",
        "target: " + get_label_info(":$target_name", "label_with_toolchain"),
        "default_toolchain: $default_toolchain",
      ]
      args += [ "--fail=$_msg" ]
    }
  }
}
  template("process_java_prebuilt") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])

    assert(invoker.build_config != "")
    _build_config = invoker.build_config
    _rebased_build_config = rebase_path(_build_config, root_build_dir)
    assert(_rebased_build_config != "" || true)  # Mark used.

    _proguard_preprocess =
        defined(invoker.proguard_preprocess) && invoker.proguard_preprocess
    _input_jar_path = invoker.input_jar_path
    _output_jar_path = invoker.output_jar_path

    _jar_excluded_patterns = []
    if (defined(invoker.jar_excluded_patterns)) {
      _jar_excluded_patterns = invoker.jar_excluded_patterns
    }
    _strip_resource_classes = defined(invoker.strip_resource_classes) &&
                              invoker.strip_resource_classes
    _filter_jar = _jar_excluded_patterns != [] || _strip_resource_classes

    if (_filter_jar) {
      _filter_target = "${target_name}__filter"
      _output_jar_target = _filter_target
    }
    if (_proguard_preprocess) {
      _proguard_target = "${target_name}__proguard_process"
      _output_jar_target = _proguard_target
    }
    if (!_filter_jar && !_proguard_preprocess) {
      _copy_target = "${target_name}__copy"
      _output_jar_target = _copy_target
    }

    if (_filter_jar) {
      _filtered_jar_path = _output_jar_path
      if (_proguard_preprocess) {
        _filtered_jar_path = "$target_out_dir/$target_name-filtered.jar"
      }
      action(_filter_target) {
        script = "//build/android/gyp/jar.py"
        forward_variables_from(invoker,
                               [
                                 "deps",
                                 "public_deps",
                               ])
        inputs = [
          _build_config,
          _input_jar_path,
        ]
        outputs = [
          _filtered_jar_path,
        ]
        args = [
          "--input-jar",
          rebase_path(_input_jar_path, root_build_dir),
          "--jar-path",
          rebase_path(_filtered_jar_path, root_build_dir),
          "--excluded-classes=$_jar_excluded_patterns",
        ]
        if (_strip_resource_classes) {
          args += [ "--strip-resource-classes-for=@FileArg($_rebased_build_config:javac:resource_packages)" ]
        }
      }
    }

    if (_proguard_preprocess) {
      _proguard_config_path = invoker.proguard_preprocess_config
      proguard(_proguard_target) {
        if (_filter_jar) {
          _proguard_input_jar = _filtered_jar_path
          public_deps = [
            ":$_filter_target",
          ]
        } else {
          _proguard_input_jar = _input_jar_path
          public_deps = []
        }
        if (defined(invoker.deps)) {
          deps = invoker.deps
        }
        if (defined(invoker.public_deps)) {
          public_deps += invoker.public_deps
        }
        inputs = [
          _build_config,
          _proguard_config_path,
          _proguard_input_jar,
        ]
        output_jar_path = _output_jar_path

        _rebased_input_paths = [ rebase_path(_input_jar_path, root_build_dir) ]
        _rebased_proguard_configs =
            [ rebase_path(_proguard_config_path, root_build_dir) ]
        args = [
          "--input-paths=$_rebased_input_paths",
          "--proguard-configs=$_rebased_proguard_configs",
          "--classpath=@FileArg($_rebased_build_config:javac:classpath)",
        ]
      }
    } else if (!_filter_jar) {
      copy(_copy_target) {
        forward_variables_from(invoker,
                               [
                                 "deps",
                                 "public_deps",
                               ])
        sources = [
          _input_jar_path,
        ]
        outputs = [
          _output_jar_path,
        ]
      }
    }

    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "data_deps",
                               "visibility",
                             ])
      public_deps = [
        ":$_output_jar_target",
      ]
    }
  }
  template("java_prebuilt_impl") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])
    _supports_android =
        defined(invoker.supports_android) && invoker.supports_android

    assert(defined(invoker.jar_path))
    _base_path = "${target_gen_dir}/$target_name"

    # Jar files can be needed at runtime (by Robolectric tests or java binaries),
    # so do not put them under gen/.
    _target_dir_name = get_label_info(":$target_name", "dir")
    _jar_path = "$root_out_dir/lib.java$_target_dir_name/$target_name.jar"
    _ijar_path =
        "$root_out_dir/lib.java$_target_dir_name/$target_name.interface.jar"
    _build_config = _base_path + ".build_config"

    if (_supports_android) {
      _dex_path = _base_path + ".dex.jar"
    }
    _deps = []
    if (defined(invoker.deps)) {
      _deps = invoker.deps
    }
    _jar_deps = []
    if (defined(invoker.jar_dep)) {
      _jar_deps = [ invoker.jar_dep ]
    }

    _template_name = target_name

    _build_config_target_name = "${_template_name}__build_config"
    _process_jar_target_name = "${_template_name}__process_jar"
    _ijar_target_name = "${_template_name}__ijar"
    if (_supports_android) {
      _dex_target_name = "${_template_name}__dex"
    }

    write_build_config(_build_config_target_name) {
      type = "java_prebuilt"
      forward_variables_from(invoker,
                             [
                               "input_jars_paths",
                               "proguard_configs",
                             ])
      supports_android = _supports_android
      requires_android =
          defined(invoker.requires_android) && invoker.requires_android

      if (defined(invoker.deps)) {
        possible_config_deps = _deps
      }
      build_config = _build_config
      jar_path = _jar_path
      if (_supports_android) {
        dex_path = _dex_path
      }
    }

    process_java_prebuilt(_process_jar_target_name) {
      forward_variables_from(invoker,
                             [
                               "jar_excluded_patterns",
                               "proguard_preprocess",
                               "proguard_preprocess_config",
                               "strip_resource_classes",
                             ])

      visibility = [
        ":$_ijar_target_name",
        ":$_template_name",
      ]
      if (_supports_android) {
        visibility += [ ":$_dex_target_name" ]
      }

      build_config = _build_config
      input_jar_path = invoker.jar_path
      output_jar_path = _jar_path

      deps = [ ":$_build_config_target_name" ] + _deps + _jar_deps
    }

    generate_interface_jar(_ijar_target_name) {
      if (!defined(invoker.proguard_preprocess) ||
          !invoker.proguard_preprocess) {
        # Always used the unfiltered .jar to create the interface jar so that
        # other targets will resolve filtered classes when depending on
        # BuildConfig, NativeLibraries, etc.
        input_jar = invoker.jar_path
        deps = _deps + _jar_deps
      } else {
        # However, still apply pre-proguarding, since ignoring that can break
        # compiles.
        input_jar = _jar_path
        deps = [
          ":$_process_jar_target_name",
        ]
      }

      output_jar = _ijar_path
    }

    if (_supports_android) {
      dex(_dex_target_name) {
        sources = [
          _jar_path,
        ]
        output = _dex_path
        deps = [ ":$_process_jar_target_name" ] + _deps + _jar_deps
      }
    }

    if (defined(invoker.main_class)) {
      _binary_script_target_name = "${_template_name}__java_binary_script"
      java_binary_script(_binary_script_target_name) {
        forward_variables_from(invoker,
                               [
                                 "bootclasspath",
                                 "deps",
                                 "main_class",
                                 "wrapper_script_args",
                               ])
        if (!defined(deps)) {
          deps = []
        }
        build_config = _build_config
        jar_path = _jar_path
        script_name = _template_name
        if (defined(invoker.wrapper_script_name)) {
          script_name = invoker.wrapper_script_name
        }
        deps += [ ":$_build_config_target_name" ]
      }
    }

    group(target_name) {
      forward_variables_from(invoker, [ "data_deps" ])
      public_deps = [
        ":$_ijar_target_name",
        ":$_process_jar_target_name",
      ]
      if (_supports_android) {
        public_deps += [ ":$_dex_target_name" ]
      }
      if (defined(invoker.main_class)) {
        # Some targets use the generated script while building, so make it a dep
        # rather than a data_dep.
        public_deps += [ ":$_binary_script_target_name" ]
      }
    }
  }
# // write_build_config


