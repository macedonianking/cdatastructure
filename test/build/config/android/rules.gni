import("//build/config/android/config.gni")
import("//build/config/android/internal_rules.gni")

assert(is_android)


  # Declare a target for c-preprocessor-generated java files
  #
  # NOTE: For generating Java conterparts to enums prefer using the java_cpp_enum
  #       rule instead.
  #
  # This target generates java files using the host C pre-processor. Each file in
  # sources will be compiled using the C pre-processor. If include_path is
  # specified, it will be passed (with --I) to the pre-processor.
  #
  # This target will create a single .srcjar. Adding this target to an
  # android_library target's srcjar_deps will make the generated java files be
  # included in that library's final outputs.
  #
  # Variables
  #   sources: list of files to be processed by the C pre-processor. For each
  #     file in sources, there will be one .java file in the final .srcjar. For a
  #     file named FooBar.template, a java file will be created with name
  #     FooBar.java.
  #   inputs: additional compile-time dependencies. Any files
  #     `#include`-ed in the templates should be listed here.
  #   package_name: this will be the subdirectory for each .java file in the
  #     .srcjar.
  #
  # Example
  #   java_cpp_template("foo_generated_enum") {
  #     sources = [
  #       "android/java/templates/Foo.template",
  #     ]
  #     inputs = [
  #       "android/java/templates/native_foo_header.h",
  #     ]
  #
  #     package_name = "org/chromium/base/library_loader"
  #     include_path = "android/java/templates"
  #   }
  template("java_cpp_template") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])

    _include_path = "//"
    if (defined(invoker.include_path)) {
      _include_path = invoker.include_path
    }

    _apply_gcc_target_name = "${target_name}__apply_gcc"
    _base_gen_dir = "${target_gen_dir}/${target_name}/java_cpp_template"

    action_foreach(_apply_gcc_target_name) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "public_deps",
                               "data_deps",
                             ])
      script = "//build/android/gyp/gcc_preprocess.py"
      if (defined(invoker.inputs)) {
        inputs = invoker.inputs + []
      }
      depfile =
          "${target_gen_dir}/${invoker.target_name}_{{source_name_part}}.d"

      sources = invoker.sources

      outputs = [
        "$_base_gen_dir/${invoker.package_name}/{{source_name_part}}.java",
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--include-path",
        rebase_path(_include_path, root_build_dir),
        "--output",
        rebase_path(outputs[0], root_build_dir),
        "--template={{source}}",
      ]

      if (defined(invoker.defines)) {
        foreach(def, invoker.defines) {
          args += [
            "--defines",
            def,
          ]
        }
      }
    }

    # Filter out .d files.
    set_sources_assignment_filter([ "*.d" ])
    sources = get_target_outputs(":$_apply_gcc_target_name")

    zip(target_name) {
      forward_variables_from(invoker, [ "visibility" ])
      inputs = sources
      output = "${target_gen_dir}/${target_name}.srcjar"
      base_dir = _base_gen_dir
      deps = [
        ":$_apply_gcc_target_name",
      ]
    }
  }


  # Declare an Android resources target
  #
  # This creates a resources zip file that will be used when building an Android
  # library or apk and included into a final apk.
  #
  # To include these resources in a library/apk, this target should be listed in
  # the library's deps. A library/apk will also include any resources used by its
  # own dependencies.
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Any Android resources
  #     listed in deps will be included by libraries/apks that depend on this
  #     target.
  #   resource_dirs: List of directories containing resources for this target.
  #   generated_resource_dirs: List of directories containing resources for this
  #     target which are *generated* by a dependency. |generated_resource_files|
  #     must be specified if |generated_resource_dirs| is specified.
  #   generated_resource_files: List of all files in |generated_resource_dirs|.
  #     |generated_resource_dirs| must be specified in |generated_resource_files|
  #     is specified.
  #   android_manifest: AndroidManifest.xml for this target. Defaults to
  #     //build/android/AndroidManifest.xml.
  #   android_manifest_dep: Target that generates AndroidManifest (if applicable)
  #   custom_package: java package for generated .java files.
  #   v14_skip: If true, don't run v14 resource generator on this. Defaults to
  #     false. (see build/android/gyp/generate_v14_compatible_resources.py)
  #   shared_resources: If true make a resource package that can be loaded by a
  #     different application at runtime to access the package's resources.
  #   app_as_shared_lib: If true make a resource package that can be loaded as
  #     both shared_resources and normal application.

  # Example:
  #   android_resources("foo_resources") {
  #     deps = [":foo_strings_grd"]
  #     resource_dirs = ["res"]
  #     custom_package = "org.chromium.foo"
  #   }
  #
  #   android_resources("foo_resources_overrides") {
  #     deps = [":foo_resources"]
  #     resource_dirs = ["res_overrides"]
  #   }
  template("android_resources") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])

    assert(defined(invoker.resource_dirs))

    base_path = "$target_gen_dir/$target_name"
    zip_path = base_path + ".resources.zip"
    srcjar_path = base_path + ".srcjar"
    r_text_path = base_path + "_R.txt"
    build_config = base_path + ".build_config"

    build_config_target_name = "${target_name}__build_config"
    process_resources_target_name = "${target_name}__process_resources"
    final_target_name = target_name

    write_build_config(build_config_target_name) {
      type = "android_resources"
      forward_variables_from(invoker,
                             [
                               "android_manifest",
                               "custom_package",
                             ])
      resource_dirs = []
      if (defined(invoker.resource_dirs)) {
        resource_dirs += invoker.resource_dirs
      }
      if (defined(invoker.generated_resource_dirs)) {
        resource_dirs += invoker.generated_resource_dirs
      }

      if (defined(invoker.deps)) {
        possible_config_deps = invoker.deps
      }
      if (defined(invoker.android_manifest_dep)) {
        deps = [
          invoker.android_manifest_dep,
        ]
      }

      # No package means resources override their deps.
      if (defined(custom_package) || defined(android_manifest)) {
        r_text = r_text_path
      } else {
        assert(defined(invoker.deps),
               "Must specify deps when custom_package is omitted.")
      }

      resources_zip = zip_path
      srcjar = srcjar_path
    }

    process_resources(process_resources_target_name) {
      forward_variables_from(invoker,
                             [
                               "app_as_shared_lib",
                               "android_manifest",
                               "custom_package",
                               "deps",
                               "generated_resource_dirs",
                               "generated_resource_files",
                               "resource_dirs",
                               "shared_resources",
                               "v14_skip",
                             ])
      if (!defined(deps)) {
        deps = []
      }
      deps += [ ":$build_config_target_name" ]
      if (defined(invoker.android_manifest_dep)) {
        deps += [ invoker.android_manifest_dep ]
      }

      # Always generate R.onResourcesLoaded() method, it is required for
      # compiling ResourceRewriter, there is no side effect because the
      # generated R.class isn't used in final apk.
      shared_resources = true
      if (!defined(android_manifest)) {
        android_manifest = "//build/android/AndroidManifest.xml"
      }
    }

    group(final_target_name) {
      forward_variables_from(invoker, [ "visibility" ])
      public_deps = [
        ":${target_name}__process_resources",
      ]
    }
  }

  # Declare an Android assets target.
  #
  # Defines a set of files to include as assets in a dependent apk.
  #
  # To include these assets in an apk, this target should be listed in
  # the apk's deps, or in the deps of a library target used by an apk.
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Any Android assets
  #     listed in deps will be included by libraries/apks that depend on this
  #     target.
  #   sources: List of files to include as assets.
  #   renaming_sources: List of files to include as assets and be renamed.
  #   renaming_destinations: List of asset paths for files in renaming_sources.
  #   disable_compression: Whether to disable compression for files that are
  #     known to be compressable (default: false).
  #
  # Example:
  # android_assets("content_shell_assets") {
  #   deps = [
  #     ":generates_foo",
  #     ":other_assets",
  #     ]
  #   sources = [
  #     "//path/asset1.png",
  #     "//path/asset2.png",
  #     "$target_gen_dir/foo.dat",
  #   ]
  # }
  #
  # android_assets("overriding_content_shell_assets") {
  #   deps = [ ":content_shell_assets" ]
  #   # Override foo.dat from content_shell_assets.
  #   sources = [ "//custom/foo.dat" ]
  #   renaming_sources = [ "//path/asset2.png" ]
  #   renaming_destinations = [ "renamed/asset2.png" ]
  # }
  template("android_assets") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])

    _build_config = "$target_gen_dir/$target_name.build_config"
    _build_config_target_name = "${target_name}__build_config"

    write_build_config(_build_config_target_name) {
      type = "android_assets"
      build_config = _build_config

      forward_variables_from(invoker, [ "disable_compression" ])

      if (defined(invoker.deps)) {
        possible_config_deps = invoker.deps
      }

      if (defined(invoker.sources)) {
        asset_sources = invoker.sources
      }
      if (defined(invoker.renaming_sources)) {
        assert(defined(invoker.renaming_destinations))
        _source_count = 0
        foreach(_, invoker.renaming_sources) {
          _source_count += 1
        }
        _dest_count = 0
        foreach(_, invoker.renaming_destinations) {
          _dest_count += 1
        }
        assert(
            _source_count == _dest_count,
            "android_assets() renaming_sources.length != renaming_destinations.length")
        asset_renaming_sources = invoker.renaming_sources
        asset_renaming_destinations = invoker.renaming_destinations
      }
    }

    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "visibility",
                             ])
      public_deps = [
        ":$_build_config_target_name",
      ]
    }
  }

  # Declare a group() that supports forwarding java dependency information.
  #
  # Example
  #  java_group("conditional_deps") {
  #    if (enable_foo) {
  #      deps = [":foo_java"]
  #    }
  #  }
  template("java_group") {
    forward_variables_from(invoker, [ "testonly" ])
    write_build_config("${target_name}__build_config") {
      type = "group"
      build_config = "$target_gen_dir/${invoker.target_name}.build_config"
      if (defined(invoker.deps)) {
        possible_config_deps = invoker.deps
      }
    }
    group(target_name) {
      forward_variables_from(invoker, "*")
      if (!defined(deps)) {
        deps = []
      }
      deps += [ ":${target_name}__build_config" ]
    }
  }


  # Declare a Java executable target
  #
  # This target creates an executable from java code and libraries. The executable
  # will be in the output folder's /bin/ directory.
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Java targets in this list
  #     will be included in the executable (and the javac classpath).
  #   java_files: List of .java files included in this library.
  #   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
  #     will be added to java_files and be included in this library.
  #   srcjars: List of srcjars to be included in this library, together with the
  #     ones obtained from srcjar_deps.
  #   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
  #     dependencies for this target. This will allow depending on an
  #     android_library target, for example.
  #   chromium_code: If true, extra analysis warning/errors will be enabled.
  #   enable_errorprone: If true, enables the errorprone compiler.
  #   enable_incremental_javac_override: Overrides the
  #     global enable_incremental_javac.
  #   main_class: When specified, a wrapper script is created within
  #     $root_build_dir/bin to launch the binary with the given class as the
  #     entrypoint.
  #   wrapper_script_args: List of additional arguments for the wrapper script.
  #
  #   data_deps, testonly
  #
  # Example
  #   java_binary("foo") {
  #     java_files = [ "org/chromium/foo/FooMain.java" ]
  #     deps = [ ":bar_java" ]
  #     main_class = "org.chromium.foo.FooMain"
  #   }
  template("java_binary") {
    set_sources_assignment_filter([])

    java_library_impl(target_name) {
      forward_variables_from(invoker, "*")
      supports_android = false
      main_class = invoker.main_class
      is_java_binary = true
    }
  }

  # Declare a java library target
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Java targets in this list
  #     will be added to the javac classpath.
  #
  #   java_files: List of .java files included in this library.
  #   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
  #     will be added to java_files and be included in this library.
  #   srcjars: List of srcjars to be included in this library, together with the
  #     ones obtained from srcjar_deps.
  #
  #   input_jars_paths: A list of paths to the jars that should be included
  #     in the classpath. These are in addition to library .jars that
  #     appear in deps.
  #
  #   chromium_code: If true, extra analysis warning/errors will be enabled.
  #   enable_errorprone: If true, enables the errorprone compiler.
  #   enable_incremental_javac_override: Overrides the global
  #     enable_incremental_javac.
  #
  #   jar_excluded_patterns: List of patterns of .class files to exclude from the
  #     final jar.
  #
  #   proguard_preprocess: If true, proguard preprocessing will be run. This can
  #     be used to remove unwanted parts of the library.
  #   proguard_preprocess_config: Path to the proguard config for preprocessing.
  #   proguard_configs: List of proguard configs to use in final apk step for
  #     any apk that depends on this library.
  #
  #   supports_android: If true, Android targets (android_library, android_apk)
  #     may depend on this target. Note: if true, this target must only use the
  #     subset of Java available on Android.
  #   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
  #     dependencies for this target. This will allow depending on an
  #     android_library target, for example.
  #
  #   additional_jar_files: Use to package additional files into the output jar.
  #     Pass a list of length-2 lists with format
  #     [ [ path_to_file, path_to_put_in_jar ] ]
  #
  #
  #   data_deps, testonly
  #
  # Example
  #   java_library("foo_java") {
  #     java_files = [
  #       "org/chromium/foo/Foo.java",
  #       "org/chromium/foo/FooInterface.java",
  #       "org/chromium/foo/FooService.java",
  #     ]
  #     deps = [
  #       ":bar_java"
  #     ]
  #     srcjar_deps = [
  #       ":foo_generated_enum"
  #     ]
  #     jar_excluded_patterns = [
  #       "*/FooService.class", "*/FooService\$*.class"
  #     ]
  #   }
  template("java_library") {
    set_sources_assignment_filter([])
    java_library_impl(target_name) {
      forward_variables_from(invoker, "*")
    }
  }

  # Declare a java library target for a prebuilt jar
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Java targets in this list
  #     will be added to the javac classpath.
  #   jar_path: Path to the prebuilt jar.
  #   jar_dep: Target that builds jar_path (optional).
  #   proguard_preprocess: If true, proguard preprocessing will be run. This can
  #     be used to remove unwanted parts of the library.
  #   proguard_preprocess_config: Path to the proguard config for preprocessing.
  #   proguard_configs: List of proguard configs to use in final apk step for
  #     any apk that depends on this library.
  #   supports_android: If true, Android targets (android_library, android_apk)
  #     may depend on this target. Note: if true, this target must only use the
  #     subset of Java available on Android.
  #
  # Example
  #   java_prebuilt("foo_java") {
  #     jar_path = "foo.jar"
  #     deps = [
  #       ":foo_resources",
  #       ":bar_java"
  #     ]
  #   }
  template("java_prebuilt") {
    set_sources_assignment_filter([])
    java_prebuilt_impl(target_name) {
      forward_variables_from(invoker, "*")
    }
  }

  # Declare an Android library target
  #
  # This target creates an Android library containing java code and Android
  # resources.
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Java targets in this list
  #     will be added to the javac classpath. Android resources in dependencies
  #     will be used when building this library.
  #
  #   java_files: List of .java files included in this library.
  #   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
  #     will be added to java_files and be included in this library.
  #   srcjars: List of srcjars to be included in this library, together with the
  #     ones obtained from srcjar_deps.
  #
  #   input_jars_paths: A list of paths to the jars that should be included
  #     in the classpath. These are in addition to library .jars that
  #     appear in deps.
  #
  #   chromium_code: If true, extra analysis warning/errors will be enabled.
  #   enable_errorprone: If true, enables the errorprone compiler.
  #   enable_incremental_javac_override: Overrides the global
  #     enable_incremental_javac.
  #
  #   jar_excluded_patterns: List of patterns of .class files to exclude from the
  #     final jar.
  #
  #   proguard_preprocess: If true, proguard preprocessing will be run. This can
  #     be used to remove unwanted parts of the library.
  #   proguard_preprocess_config: Path to the proguard config for preprocessing.
  #   proguard_configs: List of proguard configs to use in final apk step for
  #     any apk that depends on this library.
  #
  #   dex_path: If set, the resulting .dex.jar file will be placed under this
  #     path.
  #
  #   alternative_android_sdk_ijar: if set, the given android_sdk_ijar file
  #     replaces the default android_sdk_ijar.
  #
  #   alternative_android_sdk_ijar_dep: the target that generates
  #      alternative_android_sdk_ijar, must be set if alternative_android_sdk_ijar
  #      is used.
  #
  #   emma_never_instrument: Disables EMMA Java code coverage for this target.
  #
  # Example
  #   android_library("foo_java") {
  #     java_files = [
  #       "android/org/chromium/foo/Foo.java",
  #       "android/org/chromium/foo/FooInterface.java",
  #       "android/org/chromium/foo/FooService.java",
  #     ]
  #     deps = [
  #       ":bar_java"
  #     ]
  #     srcjar_deps = [
  #       ":foo_generated_enum"
  #     ]
  #     jar_excluded_patterns = [
  #       "*/FooService.class", "*/FooService\$*.class"
  #     ]
  #   }
  template("android_library") {
    set_sources_assignment_filter([])
    assert(!defined(invoker.jar_path),
           "android_library does not support a custom jar path")

    if (defined(invoker.alternative_android_sdk_ijar)) {
      assert(defined(invoker.alternative_android_sdk_ijar_dep))
    }

    java_library_impl(target_name) {
      forward_variables_from(invoker, "*")

      supports_android = true
      requires_android = true

      if (!defined(jar_excluded_patterns)) {
        jar_excluded_patterns = []
      }
      jar_excluded_patterns += [
        "*/R.class",
        "*/R\$*.class",
        "*/Manifest.class",
        "*/Manifest\$*.class",
      ]
    }
  }

  # Declare a target that packages a set of Java dependencies into a standalone
  # .dex.jar.
  #
  # Variables
  #   deps: specifies the dependencies of this target. Android libraries in deps
  #     will be packaged into the resulting .dex.jar file.
  #   dex_path: location at which the output file will be put
  template("android_standalone_library") {
    set_sources_assignment_filter([])
    deps_dex(target_name) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "dex_path",
                               "excluded_jars",
                             ])
    }
  }

  # Declare an Android library target for a prebuilt jar
  #
  # This target creates an Android library containing java code and Android
  # resources.
  #
  # Variables
  #   deps: Specifies the dependencies of this target. Java targets in this list
  #     will be added to the javac classpath. Android resources in dependencies
  #     will be used when building this library.
  #   jar_path: Path to the prebuilt jar.
  #   proguard_preprocess: If true, proguard preprocessing will be run. This can
  #     be used to remove unwanted parts of the library.
  #   proguard_preprocess_config: Path to the proguard config for preprocessing.
  #   proguard_configs: List of proguard configs to use in final apk step for
  #     any apk that depends on this library.
  #
  # Example
  #   android_java_prebuilt("foo_java") {
  #     jar_path = "foo.jar"
  #     deps = [
  #       ":foo_resources",
  #       ":bar_java"
  #     ]
  #   }
  template("android_java_prebuilt") {
    set_sources_assignment_filter([])
    java_prebuilt_impl(target_name) {
      forward_variables_from(invoker, "*")
      supports_android = true
      requires_android = true
      strip_resource_classes = true
    }
  }

  # Declare an Android apk target
  #
  # This target creates an Android APK containing java code, resources, assets,
  # and (possibly) native libraries.
  #
  # Variables
  #   alternative_android_sdk_jar: The alternative android sdk jar used in
  #     proguard.
  #   android_aapt_path: Android aapt tool to replace default one to build
  #     resource.
  #   android_manifest: Path to AndroidManifest.xml.
  #   android_manifest_dep: Target that generates AndroidManifest (if applicable)
  #   chromium_code: If true, extra analysis warning/errors will be enabled.
  #   create_dist_ijar: Whether to define the "${target_name}_dist_ijar" target
  #     (used by instrumentation_test_apk).
  #   data_deps: List of dependencies needed at runtime. These will be built but
  #     won't change the generated .apk in any way (in fact they may be built
  #     after the .apk is).
  #   deps: List of dependencies. All Android java resources and libraries in the
  #     "transitive closure" of these dependencies will be included in the apk.
  #     Note: this "transitive closure" actually only includes such targets if
  #     they are depended on through android_library or android_resources targets
  #     (and so not through builtin targets like 'action', 'group', etc).
  #   install_script_name: Name of wrapper script (default=target_name).
  #   java_files: List of .java files to include in the apk.
  #   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
  #      will be added to java_files and be included in this apk.
  #   apk_name: Name for final apk.
  #   final_apk_path: Path to final built apk. Default is
  #     $root_out_dir/apks/$apk_name.apk. Setting this will override apk_name.
  #   loadable_modules: List of paths to native libraries to include. Different
  #     from |shared_libraries| in that:
  #       * dependencies of this .so are not automatically included
  #       * ".cr.so" is never added
  #       * they are not side-loaded for _incremental targets.
  #       * load_library_from_apk, use_chromium_linker,
  #         and enable_relocation_packing do not apply
  #     Use this instead of shared_libraries when you are going to load the library
  #     conditionally, and only when shared_libraries doesn't work for you.
  #   shared_libraries: List shared_library targets to bundle. If these
  #     libraries depend on other shared_library targets, those dependencies will
  #     also be included in the apk (e.g. for is_component_build).
  #   secondary_abi_shared_libraries: secondary abi shared_library targets to
  #     bundle. If these libraries depend on other shared_library targets, those
  #     dependencies will also be included in the apk (e.g. for is_component_build).
  #   native_lib_placeholders: List of placeholder filenames to add to the apk
  #     (optional).
  #   apk_under_test: For an instrumentation test apk, this is the target of the
  #     tested apk.
  #   include_all_resources - If true include all resource IDs in all generated
  #     R.java files.
  #   testonly: Marks this target as "test-only".
  #   write_asset_list: Adds an extra file to the assets, which contains a list of
  #     all other asset files.
  #   requires_sdk_api_level_23: If defined and true, the apk is intended for
  #     installation only on Android M or later. In these releases the system
  #     linker does relocation unpacking, so we can enable it unconditionally.
  #   secondary_native_libs (deprecated): The path of native libraries for secondary
  #     app abi.
  #   run_findbugs_override: Forces run_findbugs on or off. If undefined, the
  #     default will use the build arg run_findbugs.
  #   proguard_jar_path: The path to proguard.jar you wish to use. If undefined,
  #     the proguard used will be the checked in one in //third_party/proguard.
  #
  # Example
  #   android_apk("foo_apk") {
  #     android_manifest = "AndroidManifest.xml"
  #     java_files = [
  #       "android/org/chromium/foo/FooApplication.java",
  #       "android/org/chromium/foo/FooActivity.java",
  #     ]
  #     deps = [
  #       ":foo_support_java"
  #       ":foo_resources"
  #     ]
  #     srcjar_deps = [
  #       ":foo_generated_enum"
  #     ]
  #     shared_libraries = [
  #       ":my_shared_lib",
  #     ]
  #   }
  template("android_apk") {
    set_sources_assignment_filter([])
    forward_variables_from(invoker, [ "testonly" ])

    assert(defined(invoker.final_apk_path) || defined(invoker.apk_name))
    assert(defined(invoker.android_manifest))
    gen_dir = "$target_gen_dir/$target_name"
    base_path = "$gen_dir/$target_name"
    _build_config = "$target_gen_dir/$target_name.build_config"
    resources_zip_path = "$base_path.resources.zip"
    _all_resources_zip_path = "$base_path.resources.all.zip"
    _jar_path = "$base_path.jar"
    _lib_dex_path = "$base_path.dex.jar"
    _rebased_lib_dex_path = rebase_path(_lib_dex_path, root_build_dir)
    _template_name = target_name

    enable_multidex =
        defined(invoker.enable_multidex) && invoker.enable_multidex
    if (enable_multidex) {
      final_dex_path = "$gen_dir/classes.dex.zip"
    } else {
      final_dex_path = "$gen_dir/classes.dex"
    }
    final_dex_target_name = "${_template_name}__final_dex"

    _final_apk_path = ""
    if (defined(invoker.final_apk_path)) {
      _final_apk_path = invoker.final_apk_path
    } else if (defined(invoker.apk_name)) {
      _final_apk_path = "$root_build_dir/apks/" + invoker.apk_name + ".apk"
    }
    _final_apk_path_no_ext_list =
        process_file_template([ _final_apk_path ],
                              "{{source_dir}}/{{source_name_part}}")
    _final_apk_path_no_ext = _final_apk_path_no_ext_list[0]
    assert(_final_apk_path_no_ext != "")  # Mark as used.

    _install_script_name = "install_$_template_name"
    if (defined(invoker.install_script_name)) {
      _install_script_name = invoker.install_script_name
    }
    _incremental_install_script_path =
        "${root_out_dir}/bin/${_install_script_name}_incremental"

    _version_code = android_default_version_code
    if (defined(invoker.version_code)) {
      _version_code = invoker.version_code
    }

    _version_name = android_default_version_name
    if (defined(invoker.version_name)) {
      _version_name = invoker.version_name
    }
    _keystore_path = android_keystore_path
    _keystore_name = android_keystore_name
    _keystore_password = android_keystore_password

    if (defined(invoker.keystore_path)) {
      _keystore_path = invoker.keystore_path
      _keystore_name = invoker.keystore_name
      _keystore_password = invoker.keystore_password
    }

    _srcjar_deps = []
    if (defined(invoker.srcjar_deps)) {
      _srcjar_deps += invoker.srcjar_deps
    }

    _use_chromium_linker =
        defined(invoker.use_chromium_linker) && invoker.use_chromium_linker
    _enable_relocation_packing = defined(invoker.enable_relocation_packing) &&
                                 invoker.enable_relocation_packing
    _load_library_from_apk =
        defined(invoker.load_library_from_apk) && invoker.load_library_from_apk
    _requires_sdk_api_level_23 = defined(invoker.requires_sdk_api_level_23) &&
                                 invoker.requires_sdk_api_level_23

    assert(_use_chromium_linker || true)  # Mark as used.
    assert(_requires_sdk_api_level_23 || true)
    if (_enable_relocation_packing) {
      assert(_use_chromium_linker || _requires_sdk_api_level_23,
             "enable_relocation_packing requires either use_chromium_linker " +
                 "or requires_sdk_api_level_23")
    }
    if (_load_library_from_apk) {
      assert(_use_chromium_linker || _requires_sdk_api_level_23,
             "load_library_from_apk requires use_chromium_linker " +
                 "or requires_sdk_api_level_23")
    }

    # The dependency that makes the chromium linker, if any is needed.
    _native_libs_deps = []
    _shared_libraries_is_valid =
        defined(invoker.shared_libraries) && invoker.shared_libraries != []
    _secondary_abi_native_libs_deps = []
    assert(_secondary_abi_native_libs_deps == [])  # mark as used.
    _secondary_abi_shared_libraries_is_valid =
        defined(invoker.secondary_abi_shared_libraries) &&
        invoker.secondary_abi_shared_libraries != []

#    if (is_component_build || is_asan) {
#      if (_shared_libraries_is_valid) {
#        _native_libs_deps += [ "//build/android:cpplib_stripped" ]
#      }
#      if (_secondary_abi_shared_libraries_is_valid) {
#        _secondary_abi_native_libs_deps += [ "//build/android:cpplib_stripped($android_secondary_abi_toolchain)" ]
#      }
#    }

    if (_shared_libraries_is_valid) {
      _native_libs_deps += invoker.shared_libraries

      # To determine the filenames of all dependent shared libraries, write the
      # runtime deps of |shared_libraries| to a file during "gn gen".
      # write_build_config.py will then grep this file for *.so to obtain the
      # complete list.
      _runtime_deps_file =
          "$target_gen_dir/${_template_name}.native.runtimedeps"
      group("${_template_name}__runtime_deps") {
        deps = _native_libs_deps
        write_runtime_deps = _runtime_deps_file
      }

      _native_lib_version_rule = ""
      if (defined(invoker.native_lib_version_rule)) {
        _native_lib_version_rule = invoker.native_lib_version_rule
      }
      _native_lib_version_arg = "\"\""
      if (defined(invoker.native_lib_version_arg)) {
        _native_lib_version_arg = invoker.native_lib_version_arg
      }
    }

    if (_secondary_abi_shared_libraries_is_valid) {
      _secondary_abi_native_libs_deps += invoker.secondary_abi_shared_libraries

      # To determine the filenames of all dependent shared libraries, write the
      # runtime deps of |shared_libraries| to a file during "gn gen".
      # write_build_config.py will then grep this file for *.so to obtain the
      # complete list.
      _secondary_abi_runtime_deps_file =
          "$target_gen_dir/${_template_name}.secondary.abi.native.runtimedeps"
      group("${_template_name}_secondary_abi__runtime_deps") {
        deps = _secondary_abi_native_libs_deps
        write_runtime_deps = _secondary_abi_runtime_deps_file
      }
    }

    if (defined(invoker.deps)) {
      set_sources_assignment_filter([ "*manifest*" ])
      sources = invoker.deps
      set_sources_assignment_filter([])
      if (sources != invoker.deps) {
        _bad_deps = invoker.deps - sources
        assert(
            false,
            "Possible manifest-generating dep found in deps. Use android_manifest_dep for this instead. Found: $_bad_deps")
      }
      sources = []
    }
    _android_manifest_deps = []
    if (defined(invoker.android_manifest_dep)) {
      _android_manifest_deps = [ invoker.android_manifest_dep ]
    }
    _android_manifest = invoker.android_manifest

    _rebased_build_config = rebase_path(_build_config, root_build_dir)
    _create_abi_split =
        defined(invoker.create_abi_split) && invoker.create_abi_split
    _create_density_splits =
        defined(invoker.create_density_splits) && invoker.create_density_splits
    _create_language_splits =
        defined(invoker.language_splits) && invoker.language_splits != []

    # Help GN understand that _create_abi_split is not unused (bug in GN).
    assert(_create_abi_split || true)

    _proguard_enabled =
        defined(invoker.proguard_enabled) && invoker.proguard_enabled
    if (_proguard_enabled) {
      _proguard_output_jar_path = "$base_path.proguard.jar"
    }

    _emma_never_instrument = defined(invoker.testonly) && invoker.testonly

    build_config_target = "${_template_name}__build_config"
    write_build_config(build_config_target) {
      forward_variables_from(invoker, [ "apk_under_test" ])
      type = "android_apk"
      jar_path = _jar_path
      dex_path = final_dex_path
      apk_path = _final_apk_path
      incremental_apk_path = "${_final_apk_path_no_ext}_incremental.apk"
      incremental_install_script_path = _incremental_install_script_path
      resources_zip = resources_zip_path
      build_config = _build_config
      android_manifest = _android_manifest

      deps = _android_manifest_deps

      if (defined(invoker.deps)) {
        possible_config_deps = invoker.deps
      }

      # Added emma to the target's classpath via its .build_config.
      if (emma_coverage && !_emma_never_instrument) {
        possible_config_deps += [ "//third_party/android_tools:emma_device" ]
      }

      proguard_enabled = _proguard_enabled
      if (_proguard_enabled) {
        proguard_info = "$_proguard_output_jar_path.info"
      }

      # Don't depend on the runtime_deps target in order to avoid having to
      # build the native libraries just to create the .build_config file.
      # The dep is unnecessary since the runtime_deps file is created by gn gen
      # and the runtime_deps file is added to write_build_config.py's depfile.
      if (_native_libs_deps != []) {
        shared_libraries_runtime_deps_file = _runtime_deps_file
      }
      if (_secondary_abi_native_libs_deps != []) {
        secondary_abi_shared_libraries_runtime_deps_file =
            _secondary_abi_runtime_deps_file
      }
    }

    _final_deps = []

    _generated_proguard_config = "$base_path.resources.proguard.txt"
    process_resources_target = "${_template_name}__process_resources"
    process_resources(process_resources_target) {
      forward_variables_from(invoker,
                             [
                               "alternative_android_sdk_jar",
                               "android_aapt_path",
                               "app_as_shared_lib",
                               "include_all_resources",
                               "shared_resources",
                             ])
      srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
      r_text_path = "${target_gen_dir}/${target_name}_R.txt"
      android_manifest = _android_manifest
      resource_dirs = [ "//build/android/ant/empty/res" ]
      zip_path = resources_zip_path
      all_resources_zip_path = _all_resources_zip_path
      generate_constant_ids = true
      proguard_file = _generated_proguard_config

      build_config = _build_config
      deps = _android_manifest_deps + [ ":$build_config_target" ]
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
    }
    _srcjar_deps += [ ":$process_resources_target" ]

    if (_native_libs_deps != []) {
      _enable_chromium_linker_tests = false
      if (defined(invoker.enable_chromium_linker_tests)) {
        _enable_chromium_linker_tests = invoker.enable_chromium_linker_tests
      }
      _ordered_libraries_json =
          "$target_gen_dir/$target_name.ordered_libararies.json"
      _rebased_ordered_libraries_json =
          rebase_path(_ordered_libraries_json, root_build_dir)
      _ordered_libraries_target = "${_template_name}__write_ordered_libraries"

      # TODO(agrieve): Make GN write runtime deps in dependency order so as to
      # not need this manual sorting step.
      action(_ordered_libraries_target) {
        script = "//build/android/gyp/write_ordered_libraries.py"
        deps = _native_libs_deps + [ ":$build_config_target" ]
        outputs = [
          _ordered_libraries_json,
        ]
        _rebased_android_readelf = rebase_path(android_readelf, root_build_dir)
        args = [
          "--readelf=$_rebased_android_readelf",
          "--output=$_rebased_ordered_libraries_json",
          "--libraries-dir=.",
          "--input-libraries=@FileArg($_rebased_build_config:native:libraries)",
        ]
      }

      java_cpp_template("${_template_name}__native_libraries_java") {
        package_name = "org/chromium/base/library_loader"
        sources = [
          "//base/android/java/templates/NativeLibraries.template",
        ]
        inputs = [
          _ordered_libraries_json,
        ]
        deps = [
          ":${_ordered_libraries_target}",
        ]
        if (_native_lib_version_rule != "") {
          deps += [ _native_lib_version_rule ]
        }

        defines = [
          "NATIVE_LIBRARIES_LIST=" +
              "@FileArg($_rebased_ordered_libraries_json:java_libraries_list)",
          "NATIVE_LIBRARIES_VERSION_NUMBER=$_native_lib_version_arg",
        ]
        if (_use_chromium_linker) {
          defines += [ "ENABLE_CHROMIUM_LINKER" ]
        }
        if (_load_library_from_apk) {
          defines += [ "ENABLE_CHROMIUM_LINKER_LIBRARY_IN_ZIP_FILE" ]
        }
        if (_enable_chromium_linker_tests) {
          defines += [ "ENABLE_CHROMIUM_LINKER_TESTS" ]
        }
      }
      _srcjar_deps += [ ":${_template_name}__native_libraries_java" ]
    }

    if (!defined(invoker.apk_under_test)) {
      java_cpp_template("${_template_name}__build_config_java") {
        package_name = "org/chromium/base"
        sources = [
          "//base/android/java/templates/BuildConfig.template",
        ]
        deps = [
          ":$build_config_target",
        ]

        defines = []
        if (enable_multidex) {
          defines += [ "ENABLE_MULTIDEX" ]
        }
        if (is_java_debug || dcheck_always_on) {
          defines += [ "_DCHECK_IS_ON" ]
        }
        defines += [
          "COMPRESSED_LOCALE_LIST=" +
              "@FileArg($_rebased_build_config:compressed_locales_java_list)",
          "UNCOMPRESSED_LOCALE_LIST=" +
              "@FileArg($_rebased_build_config:uncompressed_locales_java_list)",
        ]
      }
      _srcjar_deps += [ ":${_template_name}__build_config_java" ]
    }

    java_target = "${_template_name}__java"
    java_library_impl(java_target) {
      forward_variables_from(invoker,
                             [
                               "chromium_code",
                               "java_files",
                               "run_findbugs_override",
                             ])
      supports_android = true
      requires_android = true
      override_build_config = _build_config
      deps = _android_manifest_deps + [ ":$build_config_target" ]

      android_manifest = _android_manifest
      srcjar_deps = _srcjar_deps
      jar_path = _jar_path
      dex_path = _lib_dex_path
      emma_never_instrument = _emma_never_instrument

      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
      if (defined(invoker.apk_under_test)) {
        deps += [ "${invoker.apk_under_test}__java" ]
      }
      if (emma_coverage && !_emma_never_instrument) {
        deps += [ "//third_party/android_tools:emma_device" ]
      }
    }

    # TODO(cjhopman): This is only ever needed to calculate the list of tests to
    # run. See build/android/pylib/instrumentation/test_jar.py. We should be
    # able to just do that calculation at build time instead.
    if (defined(invoker.create_dist_ijar) && invoker.create_dist_ijar) {
      _dist_ijar_path = "$root_build_dir/test.lib.java/" +
                        get_path_info(_final_apk_path, "name") + ".jar"
      action("${_template_name}_dist_ijar") {
        script = "//build/android/gyp/create_dist_jar.py"
        depfile = "$target_gen_dir/$target_name.d"
        inputs = [
          _build_config,
        ]
        outputs = [
          "${_dist_ijar_path}",
        ]
        data = [
          _dist_ijar_path,
        ]
        args = [
          "--depfile",
          rebase_path(depfile, root_build_dir),
          "--output",
          rebase_path("${_dist_ijar_path}", root_build_dir),
          "--inputs=@FileArg($_rebased_build_config:dist_jar:all_interface_jars)",
        ]
        deps = [
          ":$build_config_target",  # Generates the build config file.
          ":$java_target",  # Generates the jar file.
        ]
      }
    }

    if (_proguard_enabled) {
      _proguard_configs = [ _generated_proguard_config ]
      if (defined(invoker.proguard_configs)) {
        _proguard_configs += invoker.proguard_configs
      }
      assert(_proguard_configs != [])  # Mark as used.
      _proguard_target = "${_template_name}__proguard"
      proguard(_proguard_target) {
        forward_variables_from(invoker,
                               [
                                 "alternative_android_sdk_jar",
                                 "proguard_jar_path",
                               ])
        deps = [
          ":$build_config_target",
          ":$java_target",
          ":$process_resources_target",
        ]
        inputs = [
                   _build_config,
                   _jar_path,
                 ] + _proguard_configs

        output_jar_path = _proguard_output_jar_path
        _rebased_proguard_configs =
            rebase_path(_proguard_configs, root_build_dir)
        args = [
          "--proguard-configs=$_rebased_proguard_configs",
          "--proguard-configs=@FileArg($_rebased_build_config:proguard:lib_configs)",
          "--input-paths=@FileArg($_rebased_build_config:proguard:input_paths)",
          "--classpath=@FileArg($_rebased_build_config:proguard:lib_paths)",
        ]
        if (defined(invoker.apk_under_test)) {
          deps += [
            "${invoker.apk_under_test}__build_config",
            "${invoker.apk_under_test}__proguard",
          ]
          _apk_under_test_build_config =
              get_label_info(invoker.apk_under_test, "target_gen_dir") + "/" +
              get_label_info(invoker.apk_under_test, "name") + ".build_config"
          _rebased_apk_under_test_build_config =
              rebase_path(_apk_under_test_build_config, root_build_dir)
          args += [ "--tested-apk-info=@FileArg($_rebased_apk_under_test_build_config:deps_info:proguard_info)" ]
        }
      }
      _dex_sources = [ _proguard_output_jar_path ]
      _dex_deps = [ ":$_proguard_target" ]

      _copy_proguard_mapping_target = "${_template_name}__copy_proguard_mapping"
      copy(_copy_proguard_mapping_target) {
        sources = [
          "$_proguard_output_jar_path.mapping",
        ]
        outputs = [
          "$_final_apk_path.mapping",
        ]
        deps = [
          ":$_proguard_target",
        ]
      }
    } else {
      if (enable_multidex) {
        _dex_sources = [ _jar_path ]
      } else {
        _dex_sources = [ _lib_dex_path ]
      }
      _dex_deps = [ ":$java_target" ]
    }

    dex("$final_dex_target_name") {
      deps = _dex_deps + [ ":$build_config_target" ]
      inputs = [
        _build_config,
      ]
      sources = _dex_sources
      output = final_dex_path

      # All deps are already included in _dex_sources when proguard is used.
      if (!_proguard_enabled) {
        if (enable_multidex) {
          _dex_arg_key = "${_rebased_build_config}:dist_jar:dependency_jars"
        } else {
          _dex_arg_key =
              "${_rebased_build_config}:final_dex:dependency_dex_files"
        }
        args = [ "--inputs=@FileArg($_dex_arg_key)" ]
      }
    }

    _native_libs_file_arg_dep = ":$build_config_target"
    _native_libs_file_arg = "@FileArg($_rebased_build_config:native:libraries)"
    _secondary_abi_native_libs_file_arg_dep = ":$build_config_target"
    _secondary_abi_native_libs_file_arg =
        "@FileArg($_rebased_build_config:native:secondary_abi_libraries)"
    assert(_secondary_abi_native_libs_file_arg != "" &&
           _secondary_abi_native_libs_file_arg_dep != "")  # Mark as used.

    if (_native_libs_deps != [] && _enable_relocation_packing) {
      _prepare_native_target_name = "${_template_name}__prepare_native"
      _native_libs_json = "$gen_dir/packed-libs/filelist.json"
      _rebased_native_libs_json = rebase_path(_native_libs_json, root_build_dir)
      _native_libs_file_arg_dep = ":$_prepare_native_target_name"
      _native_libs_file_arg = "@FileArg($_rebased_native_libs_json:files)"

      pack_relocation_section(_prepare_native_target_name) {
        forward_variables_from(invoker,
                               [
                                 "deps",
                                 "public_deps",
                               ])
        file_list_json = _native_libs_json
        libraries_filearg =
            "@FileArg(${_rebased_build_config}:native:libraries)"
        inputs = [
          _build_config,
        ]

        deps += _native_libs_deps
        deps += [ ":$build_config_target" ]
      }
      if (_secondary_abi_native_libs_deps != []) {
        _prepare_native_target_name =
            "${_template_name}_secondary_abi__prepare_native"
        _native_libs_json =
            "$gen_dir/packed-libs/$android_secondary_abi_cpu/filelist.json"
        _rebased_native_libs_json =
            rebase_path(_native_libs_json, root_build_dir)
        _secondary_abi_native_libs_file_arg_dep =
            ":$_prepare_native_target_name"
        _secondary_abi_native_libs_file_arg =
            "@FileArg($_rebased_native_libs_json:files)"

        pack_relocation_section(_prepare_native_target_name) {
          forward_variables_from(invoker,
                                 [
                                   "deps",
                                   "public_deps",
                                 ])
          file_list_json = _native_libs_json
          libraries_filearg = "@FileArg(${_rebased_build_config}:native:secondary_abi_libraries)"
          inputs = [
            _build_config,
          ]

          deps += _secondary_abi_native_libs_deps
          deps += [ ":$build_config_target" ]
        }
      }
    }

    _extra_native_libs = []
    _extra_native_libs_deps = []
    _extra_native_libs_even_when_incremental = []
    _extra_native_libs_even_when_incremental_deps = []
    assert(_extra_native_libs_even_when_incremental_deps == [])  # Mark as used.
    if (_native_libs_deps != []) {
      # zipalign can't align gdb_server, don't pack gdbserver temporarily.
      if (is_debug && (!defined(invoker.page_align_shared_libraries) ||
                       !invoker.page_align_shared_libraries)) {
        _extra_native_libs_even_when_incremental = [ android_gdbserver ]
      }

      if (_use_chromium_linker) {
        _extra_native_libs =
            [ "$root_shlib_dir/libchromium_android_linker$shlib_extension" ]
        _extra_native_libs_deps +=
            [ "//base/android/linker:chromium_android_linker" ]
      }
    }
    if (defined(invoker.loadable_modules) && invoker.loadable_modules != []) {
      _extra_native_libs_even_when_incremental += invoker.loadable_modules
    }

    _final_deps += [ ":${_template_name}__create" ]
    create_apk("${_template_name}__create") {
      forward_variables_from(invoker,
                             [
                               "alternative_android_sdk_jar",
                               "android_aapt_path",
                               "app_as_shared_lib",
                               "deps",
                               "extensions_to_not_compress",
                               "language_splits",
                               "page_align_shared_libraries",
                               "public_deps",
                               "secondary_native_libs",
                               "shared_resources",
                               "uncompress_shared_libraries",
                               "write_asset_list",
                             ])
      if (!defined(deps)) {
        deps = []
      }
      apk_path = _final_apk_path
      android_manifest = _android_manifest
      assets_build_config = _build_config
      resources_zip = _all_resources_zip_path
      dex_path = final_dex_path
      load_library_from_apk = _load_library_from_apk
      create_density_splits = _create_density_splits
      emma_instrument = emma_coverage && !_emma_never_instrument

      if (!defined(extensions_to_not_compress)) {
        # Allow icu data, v8 snapshots, and pak files to be loaded directly from
        # the .apk.
        # Note: These are actually suffix matches, not necessarily extensions.
        extensions_to_not_compress = ".dat,.bin,.pak"
      }

      version_code = _version_code
      version_name = _version_name

      keystore_name = _keystore_name
      keystore_path = _keystore_path
      keystore_password = _keystore_password

      # Incremental apk does not use native libs nor final dex.
      incremental_deps = deps + _android_manifest_deps + [
                           ":$build_config_target",
                           ":$process_resources_target",
                         ]

      # This target generates the input file _all_resources_zip_path.
      deps += _android_manifest_deps + [
                ":$build_config_target",
                ":$process_resources_target",
                ":$final_dex_target_name",
              ]

      if ((_native_libs_deps != [] ||
           _extra_native_libs_even_when_incremental != []) &&
          !_create_abi_split) {
        deps += _native_libs_deps + _extra_native_libs_deps +
                _extra_native_libs_even_when_incremental_deps +
                [ _native_libs_file_arg_dep ]
        native_libs_filearg = _native_libs_file_arg
        native_libs = _extra_native_libs
        native_libs_even_when_incremental =
            _extra_native_libs_even_when_incremental
      }

      if (_secondary_abi_native_libs_deps != [] && !_create_abi_split) {
        deps += _secondary_abi_native_libs_deps +
                [ _secondary_abi_native_libs_file_arg_dep ]
        secondary_abi_native_libs_filearg = _secondary_abi_native_libs_file_arg
      }

      # Placeholders necessary for some older devices.
      # http://crbug.com/395038
      forward_variables_from(invoker, [ "native_lib_placeholders" ])
    }

    if ((_native_libs_deps != [] ||
         _extra_native_libs_even_when_incremental != []) && _create_abi_split) {
      _manifest_rule =
          "${_template_name}__split_manifest_abi_${android_app_abi}"
      generate_split_manifest(_manifest_rule) {
        main_manifest = _android_manifest
        out_manifest =
            "$gen_dir/split-manifests/${android_app_abi}/AndroidManifest.xml"
        split_name = "abi_${android_app_abi}"
        deps = _android_manifest_deps
      }

      _apk_rule = "${_template_name}__split_apk_abi_${android_app_abi}"
      _final_deps += [ ":$_apk_rule" ]

      create_apk(_apk_rule) {
        apk_path = "${_final_apk_path_no_ext}-abi-${android_app_abi}.apk"
        base_path = "$gen_dir/$_apk_rule"

        manifest_outputs = get_target_outputs(":${_manifest_rule}")
        android_manifest = manifest_outputs[1]
        load_library_from_apk = _load_library_from_apk

        version_code = _version_code
        version_name = _version_name

        keystore_name = _keystore_name
        keystore_path = _keystore_path
        keystore_password = _keystore_password

        # Placeholders necessary for some older devices.
        # http://crbug.com/395038
        deps = []
        forward_variables_from(invoker,
                               [
                                 "alternative_android_sdk_jar",
                                 "android_aapt_path",
                                 "deps",
                                 "native_lib_placeholders",
                                 "public_deps",
                               ])

        incremental_deps =
            deps + _extra_native_libs_even_when_incremental_deps +
            [ ":$_manifest_rule" ]
        deps = []
        deps = incremental_deps + _native_libs_deps + _extra_native_libs_deps +
               [ _native_libs_file_arg_dep ]
        native_libs_filearg = _native_libs_file_arg
        native_libs = _extra_native_libs
        native_libs_even_when_incremental =
            _extra_native_libs_even_when_incremental
      }
    }

    _create_incremental_script_rule_name =
        "${_template_name}__incremental_script"
    action(_create_incremental_script_rule_name) {
      script = "//build/android/incremental_install/create_install_script.py"
      depfile = "$target_gen_dir/$target_name.d"
      deps = [
        _native_libs_file_arg_dep,
      ]

      outputs = [
        _incremental_install_script_path,
      ]

      _rebased_apk_path_no_ext =
          rebase_path(_final_apk_path_no_ext, root_build_dir)
      _rebased_incremental_install_script_path =
          rebase_path(_incremental_install_script_path, root_build_dir)
      _rebased_depfile = rebase_path(depfile, root_build_dir)
      _dex_arg_key = "${_rebased_build_config}:final_dex:dependency_dex_files"
      args = [
        "--apk-path=${_rebased_apk_path_no_ext}_incremental.apk",
        "--script-output-path=$_rebased_incremental_install_script_path",
        "--dex-file=$_rebased_lib_dex_path",
        "--dex-file-list=@FileArg($_dex_arg_key)",
        "--depfile=$_rebased_depfile",
      ]
      if (_proguard_enabled) {
        args += [ "--show-proguard-warning" ]
      }
      if (defined(_native_libs_file_arg)) {
        args += [ "--native-libs=$_native_libs_file_arg" ]
      }
      if (_extra_native_libs != []) {
        # Don't pass in _extra_native_libs_even_when_incremental, since these are
        # end up in the apk and are not side-loaded.
        _rebased_extra_native_libs =
            rebase_path(_extra_native_libs, root_build_dir)
        args += [ "--native-libs=$_rebased_extra_native_libs" ]
      }
      if (_create_density_splits) {
        args += [ "--split=${_rebased_apk_path_no_ext}-density-*.apk" ]
      }
      if (_create_language_splits) {
        args += [ "--split=${_rebased_apk_path_no_ext}-language-*.apk" ]
      }
      if (_load_library_from_apk) {
        args += [ "--dont-even-try=Incremental builds do not work with load_library_from_apk. Try setting is_component_build=true in your GN args." ]
      }
    }

    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "data",
                               "data_deps",
                             ])
      public_deps = _final_deps

      # Make the proguard .mapping file easy to find by putting it beside the .apk.
      if (_proguard_enabled) {
        deps = [
          ":$_copy_proguard_mapping_target",
        ]
      }
    }
    group("${target_name}_incremental") {
      forward_variables_from(invoker,
                             [
                               "data",
                               "data_deps",
                             ])
      if (!defined(data_deps)) {
        data_deps = []
      }

      # device/commands is used by the installer script to push files via .zip.
      data_deps += [ "//build/android/pylib/device/commands" ] +
                   _native_libs_deps + _extra_native_libs_deps

      # Since the _incremental.apk does not include use .so nor .dex from the
      # actual target, but instead loads them at runtime, we need to explicitly
      # depend on them here.
      public_deps = [
        ":${_create_incremental_script_rule_name}",
        ":${_template_name}__create_incremental",
        ":${java_target}",
      ]
    }
  }
